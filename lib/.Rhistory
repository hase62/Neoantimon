substr(dna_trans, m_point_2, m_point_2) <- trans_to[match(tolower(m_alt), trans_from)]
}
return(dna_trans)
}
make_mutated_peptide <- function(dna_trans_mut, amino, codon){
peptide <- NULL
while(nchar(dna_trans_mut) >= 3){
a <- amino[match(substr(dna_trans_mut, 1, 3), codon)]
peptide <- c(peptide, a)
if(a=="X") break
dna_trans_mut <- substr(dna_trans_mut, 4, nchar(dna_trans_mut))
}
return(peptide)
}
generate_fraction <- function(m_point_2, max_peptide_length, peptide){
peptide_start <- ceiling(m_point_2 / 3.0) - max_peptide_length
if(peptide_start < 1) peptide_start <- 1
peptide_end <- ceiling(m_point_2 / 3.0) + max_peptide_length
if(peptide_end > length(peptide)) peptide_end <- length(peptide)
return(peptide_start:peptide_end)
}
generate_fraction_indel <- function (peptide, peptide_normal, max_peptide_length){
min_len <- min(length(peptide), length(peptide_normal))
peptide_start <- which(peptide[1:min_len] != peptide_normal[1:min_len])[1] - max_peptide_length + 1
if(is.na(peptide_start)) {
print("Peptide Start is NA")
return(NULL)
}
if(peptide_start < 1) peptide_start<-1
peptide_end<-which(rev(peptide)[1:min_len] != rev(peptide_normal)[1:min_len])[1]
if(is.na(peptide_end)) peptide_end <- min_len
peptide_end <- min_len - peptide_end + max_peptide_length + 10
if(peptide_end > length(peptide)) peptide_end = length(peptide)
peptide <- peptide[peptide_start:peptide_end]
peptide_end <- peptide_end + 10
if(peptide_end > length(peptide_normal)) peptide_end = length(peptide_normal)
peptide_normal <- peptide_normal[peptide_start:min(peptide_end, length(peptide_normal))]
return(list(peptide, peptide_normal))
}
integrate_same_peptide <- function(refFasta, fasta, fasta_wt){
i <- 1
while(i <= nrow(refFasta)){
#If mutation position, mutated peptide, normal peptide are all the same, Integrate These Peptides
#Note That, If the mutation position and chromosome number are the same, Merge script integrate them in the later process.
hit<-which((refFasta[i, 11]==refFasta[,11]) &
(refFasta[i, 14]==refFasta[,14]) &
(refFasta[i, 15]==refFasta[,15]))
if(length(hit)==1){
i<-i+1
next
}
#Collapse NM_ID, Info, Exon-start, Exon-end
temp1<-paste(refFasta[hit,3], collapse=";")
temp2<-paste(refFasta[hit,4], collapse=";")
temp3<-paste(refFasta[hit,9], collapse=";")
temp4<-paste(refFasta[hit,10], collapse=";")
refFasta[i,3]<-temp1
refFasta[i,4]<-temp2
refFasta[i,9]<-temp3
refFasta[i,10]<-temp4
refFasta<-refFasta[-hit[-1],]
if(is.null(nrow(refFasta))){
refFasta<-t(refFasta)
}
fasta<-fasta[-(c(hit[-1] * 2 - 1, hit[-1] * 2))]
fasta_wt<-fasta_wt[-(c(hit[-1] * 2 - 1, hit[-1] * 2))]
i<-i+1
}
return(list(refFasta, fasta, fasta_wt))
}
check_multiple_snvs <- function(data, multiple_variants, i, exon_start, mutation_start_column, chr_column, exon_end, chr){
multi_i <- integer(0)
if(multiple_variants & nrow(data) > 1){
multi_i <- (1:nrow(data))[-i][sapply((1:nrow(data))[-i],
function(x) length(which(exon_start < data[x, mutation_start_column] &
data[x, mutation_start_column] <= exon_end  &
data[x, chr_column] == chr)) == 1)]
}
return(multi_i)
}
apply_multiple_snvs <- function(data, multiple_variants, i, exon_start, mutation_start_column, chr_column, mutation_ref_column, mutation_alt_column, exon_end, chr, strand, dna_trans_mut, trans_to, trans_from){
multi_i <- check_multiple_snvs(data, multiple_variants, i, exon_start, mutation_start_column, chr_column, exon_end, chr)
for(multi_i_element in multi_i){
m_point_2_mv <- get_relative_mutation_position(strand, exon_end, data[multi_i_element, mutation_start_column], exon_start)
dna_trans_mut <- make_mutated_dna(strand, dna_trans_mut, m_point_2_mv, data[multi_i_element, mutation_ref_column], data[multi_i_element, mutation_alt_column], trans_to, trans_from)
}
return(dna_trans_mut)
}
check_multiple_snps <- function(SNPs_vcf, exon_start, mutation_start_column, exon_end, chr){
multi_i <- integer(0)
if(nrow(SNPs_vcf) > 1){
multi_i <- (1:nrow(SNPs_vcf))[sapply((1:nrow(SNPs_vcf)),
function(x) length(which(exon_start < SNPs_vcf[x, 2] &
SNPs_vcf[x, 2] <= exon_end  &
SNPs_vcf[x, 1] == chr)) == 1)]
}
return(multi_i)
}
apply_multiple_snps <- function(SNPs_vcf, exon_start, mutation_start_column, exon_end, chr, strand, dna_trans, trans_to, trans_from){
multi_i <- check_multiple_snps(SNPs_vcf, exon_start, mutation_start_column, exon_end, chr)
for(multi_i_element in multi_i){
m_point_2_mv <- get_relative_mutation_position(strand, exon_end, SNPs_vcf[multi_i_element, 2], exon_start)
dna_trans <- make_mutated_dna(strand, dna_trans, m_point_2_mv, tolower(SNPs_vcf[multi_i_element, 4]), tolower(SNPs_vcf[multi_i_element, 5]), trans_to, trans_from)
}
return(dna_trans)
}
make_indel_dna <- function(strand, dna_trans, m_point_2, m_alt, trans_to, trans_from, m_ref){
if(strand == "+"){
if(m_ref == "-"){
#Insertion
dna_trans<-paste(substr(dna_trans, 1, m_point_2 - 1),
paste(sapply(substring(m_alt, 1:nchar(m_alt), 1:nchar(m_alt)),
function(x) trans_to[match(tolower(x), trans_from)]), collapse=""),
substr(dna_trans, m_point_2, nchar(dna_trans)), sep="")
} else {
ref_ <- substr(dna_trans, m_point_2, m_point_2 + nchar(m_ref) - 1)
alt_ <- paste(substring(tolower(m_ref), 1:nchar(m_ref), 1:nchar(m_ref)), collapse="")
match_ <- ref_ == alt_
match_length <- length(which(strsplit(ref_, "")[[1]] == strsplit(alt_, "")[[1]]))
match_pval <- 1 - pbinom(match_length, nchar(ref_), 0.25)
if(!match_ & match_pval < 0.03){
print(paste("Ref is", ref_, ", and vcf is", alt_))
print(paste("The Ref and vcf have miss-match ... but p-val(", match_pval, ") is less tnan 0.03 ... Continue Convertion. ", sep = ""))
match_ <- TRUE
}
if(match_){
dna_trans<-paste(substr(dna_trans, 1, m_point_2 - 1),
gsub("NA", "", paste(sapply(substring(m_alt, 1:nchar(m_alt), 1:nchar(m_alt)),
function(x) trans_to[match(tolower(x),trans_from)]), collapse="")),
substr(dna_trans, m_point_2 + nchar(m_ref), nchar(dna_trans)), sep="")
} else {
print("The Ref and vcf are not matched")
return(NULL)
}
}
} else {
if(m_ref == "-"){
#Insertion
dna_trans<-paste(substr(dna_trans, 1, m_point_2),
paste(sapply(rev(substring(m_alt, 1:nchar(m_alt), 1:nchar(m_alt))),
function(x) trans_to[match(tolower(x),trans_from)]), collapse=""),
substr(dna_trans, m_point_2 + 1, nchar(dna_trans)), sep="")
} else {
ref_ <- paste(substring(substr(dna_trans, m_point_2 - nchar(m_ref) + 1, m_point_2), 1:nchar(m_ref), 1:nchar(m_ref)), collapse="")
alt_ <- paste(sapply(rev(substring(tolower(m_ref), 1:nchar(m_ref), 1:nchar(m_ref))), function(x) trans_to[match(tolower(x),trans_from)]), collapse="")
match_ <- ref_ == alt_
match_length <- length(which(strsplit(ref_, "")[[1]] == strsplit(alt_, "")[[1]]))
match_pval <- 1 - pbinom(match_length, nchar(ref_), 0.25)
if(!match_ & match_pval < 0.03){
print(paste("Ref is", ref_, ", and vcf is", alt_))
print(paste("The Ref and vcf have miss-match ... but p-val(", match_pval, ") is less tnan 0.03 ... Continue Convertion. ", sep = ""))
match_ <- TRUE
}
if(match_){
dna_trans<-paste(substr(dna_trans, 1, m_point_2 - nchar(m_ref)),
gsub("NA","",paste(sapply(rev(substring(m_alt, 1:nchar(m_alt), 1:nchar(m_alt))),
function(x) trans_to[match(tolower(x),trans_from)]), collapse="")),
substr(dna_trans, m_point_2 + 1, nchar(dna_trans)), sep="")
} else {
print("The Ref and vcf are not matched")
return(NULL)
}
}
}
return(dna_trans)
}
check_multiple_snvs_to_indel <- function(data, multiple_variants, exon_start, mutation_start_column, chr_column, exon_end, chr){
multi_i <- integer(0)
if(multiple_variants & nrow(data) > 1){
multi_i <- (1:nrow(data))[sapply((1:nrow(data)),
function(x) length(which(exon_start < data[x, mutation_start_column] &
data[x, mutation_start_column] <= exon_end  &
data[x, chr_column] == chr)) == 1)]
}
return(multi_i)
}
apply_multiple_snvs_to_indel <- function(data, multiple_variants, exon_start, mutation_start_column, chr_column, mutation_ref_column, mutation_alt_column, exon_end, chr, strand, dna_trans_mut, trans_to, trans_from){
multi_i <- check_multiple_snvs_to_indel(data, multiple_variants, exon_start, mutation_start_column, chr_column, exon_end, chr)
for(multi_i_element in multi_i){
m_point_2_mv <- get_relative_mutation_position(strand, exon_end, data[multi_i_element, mutation_start_column], exon_start)
dna_trans_mut <- make_mutated_dna(strand, dna_trans_mut, m_point_2_mv, data[multi_i_element, mutation_ref_column], data[multi_i_element, mutation_alt_column], trans_to, trans_from)
}
return(dna_trans_mut)
}
check_valid_indel <- function(peptide, IgnoreShortPeptides, max_peptide_length){
X <- grep("X", peptide)
if(length(X) > 0 & IgnoreShortPeptides){
if(X < 8) {
print("Indel is Too Short")
return(TRUE)
}
}
if(max_peptide_length >= 15 & length(X) > 0 & IgnoreShortPeptides){
if(X < 15) {
print("Indel is Too Short")
return(TRUE)
}
}
return(FALSE)
}
read_data <- function(input_file){
data <- NULL
tmp <- scan(input_file, "character", sep = "\n", nlines = 200)
read_start <- grep("\\#chr", tolower(tmp))[1]
if(is.na(read_start)) read_start <- grep("\\#uploaded_variation", tolower(tmp))[1]
if(is.na(read_start)) read_start <- rev(grep("\\#", tmp))[1] + 1
if(is.na(read_start)) read_start <- grep("chr", tolower(tmp))[1]
if(is.na(read_start)) read_start <- grep("uploaded_variation", tolower(tmp))[1]
if(is.na(read_start)) read_start <- 1
print(paste("Please Confirm that Reading Start Line is", read_start))
print(tmp[read_start])
if(requireNamespace("data.table", quietly=TRUE)) {
data <- data.table::fread(input_file, stringsAsFactors=FALSE, sep="\t", skip = read_start - 1, header =TRUE, data.table = FALSE)
} else {
index <- scan(input_file, "character", sep = "\t", nlines = 1, skip = read_start - 1)
data  <- matrix(scan(input_file, "character", sep = "\t", skip = read_start), ncol = length(index), byrow = TRUE)
colnames(data) <- index
}
return(data)
}
read_refFlat <- function(refflat_file){
if(requireNamespace("data.table", quietly=TRUE)) {
list_nm <- data.table::fread(refflat_file, stringsAsFactors=FALSE, header = FALSE, sep="\t", data.table = FALSE)
} else {
index <- scan(refflat_file, "character", sep = "\t", nlines = 1)
list_nm  <- matrix(scan(refflat_file, "character", sep = "\t", skip = 1), ncol = length(index), byrow = TRUE)
}
return(list_nm)
}
read_refmrn <- function(refmrna_file){
if(requireNamespace("data.table", quietly=TRUE)) {
list_mra <- data.table::fread(refmrna_file, stringsAsFactors=FALSE, header = FALSE, sep='\t', data.table = FALSE)[, 1]
} else {
list_mra <- scan(refmrna_file, "character", sep = "\n")
}
return(list_mra)
}
read_1col_by_fread_or_scan <- function(f_name) {
if(requireNamespace("data.table", quietly=TRUE)) {
tmp <- data.table::fread(f_name, stringsAsFactors=FALSE, sep='\n', data.table = FALSE)[, 1]
} else {
tmp <- scan(f_name, "character", sep = "\n")
}
return(tmp)
}
#library("ensemblVEP")
#param <- VEPFlags()
#f_path <- "data/sample.snps.vcf"
#file <- system.file(f_path, "ex2.vcf", package="VariantAnnotation")
#gr <- ensemblVEP(file)
vep_file <- sample_vcf.vep
#Read vep data
if(is.list(vep_file) | is.matrix(vep_file)){
data <- as.matrix(vep_file)
vep_file <- paste("data", round(runif(1) * 10000), sep = ".")
} else {
data <- read_data(vep_file)
}
data <- data[grep("missense_variant|insertion|deletion|frameshift", data[, match("Consequence", colnames(data))]), ]
data
#Execute ensembl
print("Executing Transformation")
ensembl<-  useMart("ensembl", dataset="hsapiens_gene_ensembl")
values <- getBM(attributes=c("refseq_mrna", "ensembl_gene_id", "hgnc_symbol"),
filters = "ensembl_gene_id", values = data[, match("Gene", colnames(data))], mart= ensembl)
#Make annovar format data
index <- c("Chr","Start","End","Ref","Alt","Func.refGene","Gene.refGene","GeneDetail.refGene","ExonicFunc.refGene","AAChange.refGene")
data_an <- matrix(ncol = length(index), nrow = nrow(data), ".")
colnames(data_an) <- index
data_an[, match(c("Chr", "Start", "End", "Ref", "Alt", "Func.refGene", "Gene.refGene", "ExonicFunc.refGene", "AAChange.refGene"), colnames(data_an))] <-
t(apply2(data, 1, function(x) {
x <- as.character(x)
tmp <- strsplit(x[match("Location", colnames(data))], ":")[[1]]
Chr <- tmp[1]
Start <- tmp[2]
End <- tmp[2]
Ref_acid <- gsub("a|t|g|c", "", strsplit(x[match("Codons", colnames(data))], "/")[[1]][1])
Ref <- ifelse(length(grep("STRAND=1", x[match("Extra", colnames(data))])) == 1, Ref_acid, trans_to[match(tolower(Ref_acid), trans_from)])
Alt_acid <- gsub("a|t|g|c", "", strsplit(x[match("Codons", colnames(data))], "/")[[1]][2])
Alt <- ifelse(length(grep("STRAND=1", x[match("Extra", colnames(data))])) == 1, Alt_acid, trans_to[match(tolower(Alt_acid), trans_from)])
Func.refGene <- "exonic"
Gene.refGene <- paste(unique(values[which(!is.na(match(values[, 2], x[match("Gene", colnames(data))]))), 3]), collapse = ";")
ExonicFunc.refGene <- x[match("Consequence", colnames(data))]
am <- paste("c.", Ref_acid, x[match("cDNA_position", colnames(data))], Alt_acid, sep = "")
pr <- paste("p.", gsub("/", x[match("Protein_position", colnames(data))],
x[match("Amino_acids", colnames(data))]), sep = "")
tmp <- values[which(!is.na(match(values[, 2], x[match("Gene", colnames(data))]))), c(3, 1)]
if(is.null(tmp)) return(rep("", length(index) - 1))
if(nrow(tmp) == 0) return(rep("", length(index) - 1))
tmp <- tmp[tmp[, 2] != "",]
AAChange.refGene <- paste(apply2(tmp, 1, function(y) paste(c(y, "exonX", am, pr), collapse = ":")), collapse = ",")
c(Chr, Start, End, toupper(Ref), toupper(Alt), Func.refGene, Gene.refGene, ExonicFunc.refGene, AAChange.refGene)
}))
data_an
write.table(x = data_an[nchar(data_an[, 1]) > 0, ], file = paste(vep_file, ".annovar_format.txt", sep = ""),
row.names = FALSE, col.names = TRUE, quote = FALSE, sep = "\t")
library(devtools);
install_github('hase62/Neoantimon');
library(Neoantimon);
library(biomaRt)
data("sample_vcf.annovar")
data("sample_vcf.vep")
data("sample_hla_table_c1")
data("sample_refFlat.grch37")
data("sample_refMrna.grch37.fa")
data("sample_result_SNV_CLASS1_ALL")
MainSNVClass1(input_vep_format_file = sample_vcf.vep,
hla_types = sample_hla_table_c1[1,-1],
refflat_file = sample_refFlat.grch37,
refmrna_file = sample_refMrna.grch37.fa,
netMHCpan_dir = NA)
devtools
devtools::build_vignettes()
#'
#'@return Tumor_RNA_based_on_DNA: The modified amount of the corresponding RNA level based on DNA Reads.
#'
#'@return MutRatio: The mean value of the cancer cell fraction probability.
#'
#'@return MutRatio_Min: The 1\% percentile of the cancer cell fraction probability.
#'
#'@return MutRatio_Max: The 99\% percentile of the cancer cell fraction probability.
#'
#'@export
MainSVFUSIONClass2<-function(input_file,
hla_file = "here_is_a_table",
hla_types = NA,
file_name_in_hla_table = input_file,
refflat_file = paste(hmdir, "lib/refFlat.txt", sep="/"),
refmrna_file = paste(hmdir, "lib/refMrna.fa", sep="/"),
hmdir = getwd(),
job_id = "ID",
export_dir = paste("result", job_id, "SV2", sep="."),
rnaexp_file = NA,
rnabam_file = NA,
cnv_file=NA,
purity = 1,
netMHCIIpan_dir = paste(hmdir, "lib/netMHCIIpan-3.1/netMHCIIpan", sep="/"),
refdna_file = NA,
samtools_dir = NA,
bcftools_dir = NA,
chr_column = NA,
mutation_start_column = NA,
mutation_end_column = NA,
mutation_ref_column = NA,
mutation_alt_bnd_column = NA,
depth_normal_column = NA,
depth_tumor_column = NA,
nm_id_column = NA,
ambiguous_between_exon = 0,
ambiguous_codon = 0,
peptide_length = c(15),
gene_symbol_column = NA,
mate_id_column = NA,
IgnoreShortPeptides = TRUE){
#Get HLA-Type
if(file.exists(hla_file) & !is.na(hla_types[1])){
print(paste("Using:", hla_file))
}
if(file.exists(hla_file)){
hla_types <- getHLAtypes(hla_file, file_name_in_hla_table)
} else {
hla_types <- as.character(unlist(hla_types))
}
if(is.na(hla_types[1])) {
print("Please indicate hla_file and file_name_in_hla_table, or hla_types appropriately.")
return(NULL)
}
#Check Required Files
if(CheckRequiredFiles(input_file = input_file,
hla_types = hla_types,
refflat_file = refflat_file,
refmrna_file = refmrna_file)) return(NULL)
flg <- CheckRequiredColumns(input_file = input_file,
chr_column = chr_column,
mutation_start_column = mutation_start_column,
mutation_end_column = mutation_end_column,
mutation_ref_column = mutation_ref_column,
mutation_alt_column = mutation_alt_bnd_column,
nm_id_column = ifelse(is.na(nm_id_column), 0, nm_id_column),
depth_normal_column = depth_normal_column,
depth_tumor_column = depth_tumor_column)
if(length(flg)<=1) {
print("There is no available column names.")
return(NULL)
}
#Make Directory
if(!dir.exists(export_dir)) dir.create(export_dir, recursive = TRUE)
#Check nm_id and gene_symbol
if(is.na(nm_id_column) & is.na(gene_symbol_column)) {
print("Please Specify nm_id_column or genesymbol column")
return(NULL)
}
#Check nm_id and gene_symbol
if(is.na(mate_id_column)) {
print("Please Specify mate_id_column")
return(NULL)
}
#Generate FASTA and mutation Profile
job_id = paste(job_id, "SVFusion", sep = "_")
GenerateSVFusionSeq(input_file = input_file,
hmdir = hmdir,
job_id = job_id,
refflat_file = refflat_file,
refmrna_file = refmrna_file,
max_peptide_length = max(peptide_length),
chr_column = flg[1],
mutation_start_column = flg[2],
mutation_end_column = flg[3],
mutation_ref_column = flg[4],
mutation_alt_bnd_column = flg[5],
nm_id_column = flg[6],
gene_symbol_column = gene_symbol_column,
depth_normal_column = flg[7],
depth_tumor_column = flg[8],
mate_id_column = mate_id_column,
ambiguous_between_exon = ambiguous_between_exon,
ambiguous_codon = ambiguous_codon,
export_dir = export_dir,
IgnoreShortPeptides = IgnoreShortPeptides)
output_peptide_prefix <- paste(export_dir, "/", rev(strsplit(input_file, "/")[[1]])[1], ".", job_id, sep="")
output_peptide_txt_file <- paste(output_peptide_prefix, ".peptide.txt", sep="")
if(!file.exists(output_peptide_txt_file)){
print("Could not Generate Mutation File for Calculating Neoantigens. Finish.")
return(NULL)
}
RNAExpression(rnaexp_file,
output_peptide_txt_file,
width = 2,
samtools_dir,
refdna_file,
rnabam_file,
bcftools_dir,
indel = TRUE)
CCFP.Calc(cnv_file,
output_peptide_txt_file,
purity)
#NetMHCIIpan
if(is.na(netMHCIIpan_dir)){
print("netMHCIIpan is NA.")
return(NULL)
}
if(!file.exists(netMHCIIpan_dir)) {
print(paste("Did not find", netMHCIIpan_dir))
return(NULL)
}
#Execute NetMHCpan
ExeNetMHCpanClass2(output_peptide_prefix,
"peptide",
hla_types,
netMHCIIpan_dir,
peptide_length,
export_dir,
input_file,
job_id)
#Merge Results
result <- MergeINDELSVClass2(input_dir = export_dir,
file_prefix = paste(rev(strsplit(input_file, "/")[[1]])[1], job_id, sep = "."),
annotation_file = output_peptide_txt_file)
print("Successfully Finished.")
return(result)
}
setwd("~/GitHub/Neoantimon/lib")
input_file <- "data/sample_sv_bnd.txt"
data <- NULL
tmp <- scan(input_file, "character", sep = "\n", nlines = 200)
read_start <- grep("\\#chr", tolower(tmp))[1]
read_start
tmp
read_start <- grep("\\#chr", tolower(tmp))[1]
if(is.na(read_start)) read_start <- grep("\\#uploaded_variation", tolower(tmp))[1]
if(is.na(read_start)) read_start <- rev(grep("\\#", tmp))[1] + 1
if(is.na(read_start)) read_start <- grep("chr", tolower(tmp))[1]
if(is.na(read_start)) read_start <- grep("uploaded_variation", tolower(tmp))[1]
if(is.na(read_start)) read_start <- 1
print(paste("Please Confirm that Reading Start Line is", read_start))
print(tmp[read_start])
if(requireNamespace("data.table", quietly=TRUE)) {
data <- data.table::fread(input_file, stringsAsFactors=FALSE, sep="\t", skip = read_start - 1, header =TRUE, data.table = FALSE)
} else {
index <- scan(input_file, "character", sep = "\t", nlines = 1, skip = read_start - 1)
data  <- matrix(scan(input_file, "character", sep = "\t", skip = read_start), ncol = length(index), byrow = TRUE)
colnames(data) <- index
}
data
requireNamespace("data.table", quietly=TRUE)
data <- data.table::fread(input_file, stringsAsFactors=FALSE, sep="\t", skip = read_start - 1, header =TRUE, data.table = FALSE)
index <- scan(input_file, "character", sep = "\t", nlines = 1, skip = read_start - 1)
data  <- matrix(scan(input_file, "character", sep = "\t", skip = read_start), ncol = length(index), byrow = TRUE)
colnames(data) <- index
data
if(requireNamespace("data.table", quietly=TRUE)) {
data <- data.table::fread(input_file, stringsAsFactors=FALSE, sep="\t", skip = read_start - 1, header =TRUE, data.table = FALSE)
} else {
index <- scan(input_file, "character", sep = "\t", nlines = 1, skip = read_start - 1)
data  <- matrix(scan(input_file, "character", sep = "\t", skip = read_start), ncol = length(index), byrow = TRUE)
colnames(data) <- index
}
if(length(data) < 1 | is.null(data)) return(NULL)
mateIDs <- sapply(sapply(data, function(x) strsplit(x, "\t")[[1]][mate_id_column]), function(x) strsplit(x, "_")[[1]][1])
uIDs <- unique(mateIDs)[sapply(unique(mateIDs), function(x) length(which(!is.na(match(mateIDs, x)))) > 1)]
mateIDs <- sapply(sapply(data, function(x) strsplit(x, "\t")[[1]][mate_id_column]), function(x) strsplit(x, "_")[[1]][1])
mate_id_column
data
mate_id_column<-8
mateIDs <- sapply(sapply(data, function(x) strsplit(x, "\t")[[1]][mate_id_column]), function(x) strsplit(x, "_")[[1]][1])
.mateIDs <- sapply(sapply(data, function(x) strsplit(x, "\t")[[1]][mate_id_column]), function(x) strsplit(x, "_")[[1]][1])
mateIDs <- sapply(sapply(data, function(x) strsplit(x, "\t")[[1]][mate_id_column]), function(x) strsplit(x, "_")[[1]][1])
data
if(nrow(data) < 1 | is.null(data)) return(NULL)
mateIDs <- sapply(data[, mate_id_column], function(x) strsplit(x, "_")[[1]][1])
mateIDs
uIDs <- unique(mateIDs)[sapply(unique(mateIDs), function(x) length(which(!is.na(match(mateIDs, x)))) > 1)]
